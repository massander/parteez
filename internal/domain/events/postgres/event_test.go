package postgres

import (
	"context"
	"fmt"
	"testing"
	"time"

	"parteez/internal/domain/artwork"
	"parteez/internal/domain/events"
	"parteez/internal/domain/venue"
	"parteez/pkg/postgres"

	pgxtrm "github.com/avito-tech/go-transaction-manager/drivers/pgxv5/v2"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestEventStorage_Save(t *testing.T) {
	tests := []struct {
		name       string
		event      events.Event
		wantErr    bool
		err        error
		expectedId events.EventID
	}{
		{
			name: "create new",
			event: events.Event{
				// ID:          1, // id is generated by the database
				Title:       "Test",
				Description: "Test",
				Date: events.Date{
					Start: time.Date(2025, 1, 1, 12, 23, 59, 0, time.UTC),
					End:   time.Date(2025, 1, 1, 13, 6, 0, 0, time.UTC),
				},
				AgeRestriction: 18,
				LineUp: events.LineUp{
					Artists: []string{"Test"},
					Stages: []events.Stage{
						{
							Name: "Test",
							LineUp: []events.LineUpSlot{
								{
									Time:    "23:59-04:00",
									IsLive:  false,
									Artists: []string{"Test", "Test2"},
								},
								{
									Time:    "04:00-05:00",
									IsLive:  true,
									Artists: []string{"Test2"},
								},
							},
						},
					},
				},
				Genres:     []events.EventGenre{"Test"},
				Promoter:   "Test",
				TicketsURL: "https://test.com",
				Tickets: []events.Ticket{
					{
						Title:       "Test",
						Price:       100,
						Description: "Test",
					},
				},
				Status:    events.StatusDraft,
				CreatedAt: time.Now(),
				UpdatedAt: time.Now(),
			},
			expectedId: events.EventID(1),
		},
		{
			name: "create duplicate",
			event: events.Event{
				// ID:          1, // id is generated by the database
				Title: "Test",
				Date: events.Date{
					Start: time.Date(2025, 1, 1, 12, 23, 59, 0, time.UTC),
					End:   time.Date(2025, 1, 1, 13, 6, 0, 0, time.UTC),
				},
			},
			wantErr: true,
			err:     events.ErrEventAlreadyExists,
		},
		{
			name: "update existing",
			event: events.Event{
				ID:          1,
				Title:       "Updated",
				Description: "Updated",
				Date: events.Date{
					Start: time.Date(2025, 1, 1, 12, 23, 59, 0, time.UTC),
					End:   time.Date(2025, 1, 1, 13, 6, 0, 0, time.UTC),
				},
				AgeRestriction: 0,
				LineUp:         events.LineUp{},
				Genres:         []events.EventGenre{"Test"},
				Promoter:       "Test",
				TicketsURL:     "https://test.com",
				Tickets: []events.Ticket{
					{
						Title:       "Test",
						Price:       100,
						Description: "Test",
					},
				},
				Status:      events.StatusDraft,
				CreatedAt:   time.Now(),
				UpdatedAt:   time.Now(),
				PublishedAt: time.Now(),
				ArchivedAt:  time.Now(),
			},
			expectedId: events.EventID(1),
		},
		{
			name: "with not existing artwork",
			event: events.Event{
				// ID:          1,
				Title:       "Test 2",
				Description: "Test 2",
				Date: events.Date{
					Start: time.Date(2025, 1, 1, 12, 23, 59, 0, time.UTC),
					End:   time.Date(2025, 1, 1, 13, 6, 0, 0, time.UTC),
				},
				ArtworkID: 12345,
				Status:    events.StatusDraft,
				CreatedAt: time.Now(),
				UpdatedAt: time.Now(),
			},
			wantErr: true,
			err:     fmt.Errorf("%w: %w", events.ErrEvent, artwork.ErrArtworkNotFound),
		},
		{
			name: "with not existing venue",
			event: events.Event{
				// ID:          1,
				Title:       "Test 2",
				Description: "Test 2",
				Date: events.Date{
					Start: time.Date(2025, 1, 1, 12, 23, 59, 0, time.UTC),
					End:   time.Date(2025, 1, 1, 13, 6, 0, 0, time.UTC),
				},
				VenueID:   12345,
				Status:    events.StatusDraft,
				CreatedAt: time.Now(),
				UpdatedAt: time.Now(),
			},
			wantErr: true,
			err:     fmt.Errorf("%w: %w", events.ErrEvent, venue.ErrVenueNotFound),
		},
	}

	pool, err := postgres.New("postgres://postgres:postgres@localhost:5432/postgres")
	if err != nil {
		t.Fatalf("Failed connect to database: %v", err)
	}

	storage := NewEventStorage(pool, pgxtrm.DefaultCtxGetter)

	t.Cleanup(func() {
		_, err := pool.Exec(context.Background(), "TRUNCATE TABLE events RESTART IDENTITY")
		assert.NoError(t, err)
		pool.Close()
	})

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			err := storage.Save(context.Background(), &tt.event)
			if tt.wantErr {
				require.Error(t, err)
				require.Equal(t, tt.err, err)
				return
			}
			require.NoError(t, err)
			require.Equal(t, tt.expectedId, tt.event.ID)
		})
	}
}

func TestEventStorage_FindByDate(t *testing.T) {
	tests := []struct {
		name     string
		fromDate time.Time
		toDate   time.Time
		want     []*events.Event
		wantErr  bool
	}{
		{
			name:     "find by date",
			fromDate: time.Date(2025, 1, 1, 23, 59, 0, 0, time.UTC),
			toDate:   time.Date(2025, 1, 3, 4, 0, 0, 0, time.UTC),
			want: []*events.Event{
				{
					ID:    1,
					Title: "Test 1",
					Date: events.Date{
						Start: time.Date(2025, 1, 1, 23, 0, 0, 0, time.UTC),
						End:   time.Date(2025, 1, 2, 2, 0, 0, 0, time.UTC),
					},
					Status:    events.StatusDraft,
					CreatedAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
					UpdatedAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
				},
				{
					ID:    2,
					Title: "Test 2",
					Date: events.Date{
						Start: time.Date(2025, 1, 2, 23, 0, 0, 0, time.UTC),
						End:   time.Date(2025, 1, 3, 3, 0, 0, 0, time.UTC),
					},
					Status:    events.StatusDraft,
					CreatedAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
					UpdatedAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
				},
			},
		},
	}

	pool, err := postgres.New("postgres://postgres:postgres@localhost:5432/postgres")
	if err != nil {
		t.Fatalf("Failed connect to database: %v", err)
	}

	storage := NewEventStorage(pool, pgxtrm.DefaultCtxGetter)

	t.Cleanup(func() {
		_, err := pool.Exec(context.Background(), "TRUNCATE TABLE events RESTART IDENTITY")
		assert.NoError(t, err)
		pool.Close()
	})

	for i := range 5 {
		err := storage.Save(context.Background(), &events.Event{
			Title: fmt.Sprintf("Test %d", i+1),
			Date: events.Date{
				Start: time.Date(2025, 1, 1+i, 23, 0, 0, 0, time.UTC),
				End:   time.Date(2025, 1, 2+i, 2+i, 0, 0, 0, time.UTC),
			},
			Status:    events.StatusDraft,
			CreatedAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
			UpdatedAt: time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC),
		})
		require.NoError(t, err)
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := storage.FindByDate(context.Background(), tt.fromDate, tt.toDate)
			require.NoError(t, err)
			require.Equal(t, len(tt.want), len(got))
			for i, want := range tt.want {
				assert.Equal(t, want.ID, got[i].ID)
				assert.Equal(t, want.Title, got[i].Title)
				assert.Equal(t, want.Date, got[i].Date)
				assert.Equal(t, want.Status, got[i].Status)
				assert.Equal(t, want.CreatedAt, got[i].CreatedAt.UTC())
				assert.Equal(t, want.UpdatedAt, got[i].UpdatedAt.UTC())
			}
		})
	}
}
